#version 450
layout(local_size_x = 2, local_size_y = 2, local_size_z = 1) in;

struct Vertex {
    vec2 pos;
    vec3 color;
};

// 方阵维度
const int GRID_DIMEN = 4;
// 行列间隙
const float BIAS = 0.05;

// 单个正方形的4个顶点局部坐标向量
const vec2 SQUARE_LOCAL_POS[4] = vec2[](
    vec2(-1, -1), // 左下
    vec2( 1, -1), // 右下
    vec2( 1,  1), // 右上
    vec2(-1,  1)  // 左上
);

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(binding = 1) uniform UniformBuffer {
    float time;
} ubo;

void main() {
    // 计算 2D 线程索引 (x,y)
    int squareX = int(gl_GlobalInvocationID.x);
    int squareY = int(gl_GlobalInvocationID.y);
    
    // 合并为 1D 索引 (0~3)
    int squareIndex = squareY * GRID_DIMEN + squareX;
    if (squareIndex >= GRID_DIMEN * GRID_DIMEN) return;

    // 现在 squareIndex 的范围是 0~3（对应 4 个正方形）
    int row = squareIndex / GRID_DIMEN;//纵向坐标
    int col = squareIndex % GRID_DIMEN;//横向坐标

    // 计算中心位置（修正后的版本）
    float cellSize = 2.0 / float(GRID_DIMEN);
    vec2 center = vec2(
        -1 + cellSize * (0.5 + col),
        -1 + cellSize * (0.5 + row)
    );

    // 写入顶点数据
    for (int i = 0; i < 4; i++) {
        int vertexIndex = squareIndex * 4 + i;
        vertices[vertexIndex].pos = SQUARE_LOCAL_POS[i] * 0.5 * cellSize * (1 - BIAS) + center;
        vertices[vertexIndex].color = vec3(
            sin(ubo.time + float(squareIndex)), 
            cos(ubo.time + float(squareIndex)), 
            0.5
        );
    }
}